<html>

<head>
	<style>
		.modal{
		   position: fixed;
		   top: 0;
		   left: 0;
		   background-color: black;
		   z-index: 99;
		   opacity: 0.5;
		   filter: alpha(opacity=80);
		   -moz-opacity: 0.5;
		   min-height: 100%;
		   width: 100%;
	    }

		div {
			padding: 0px;
			margin: 0px;
		}

		.board {
			width: 640px;
			height: 640px;
			border: 1px solid #777;
			position: relative;
		}

		.square {
			width: 72px;
			height: 72px;
			border: 4px double black;
			float: left; /*выравнивание по левому краю*/
			z-index: 1;
			position: relative;
		}

		.square:hover {
			background: #fefefe;
			/* Цвет фона при наводе курсора*/
		}

		.figure {
			margin: 4px 0px 0px 4px;
			position: relative;
			z-index: 10;
		}

		.square_black {
			background-color: #B2956C;
		}

		.square_white {
			background-color: #FFEBB4;
		}

		.square_highlighted {
			background-color: #c4e6fd;
		}

		.figure_highlighted{
			background-color: #99d3fc;
		}
	</style>
	<script type="text/javascript" src="jquery.min.js"></script>
	<script type="text/javascript" src="jquery-ui.min.js"></script>
	<link href="jquery-ui.min.css" rel="stylesheet" />
	<script type="text/javascript" src="socket.io.js"></script>
	<script type="text/javascript">
	var whiteTurn = true;
	var playerWhite = true;
	var extr = false;		// флаг, указывающий, что ход сделан извне (другим игроком)
	var spectrator = false;	// флаг, указывающий, что мы только смотрим игру и не можем делать никаких ходов сами
	var dontHighlight = false;		// флаг, указывающий на то, что не нужно подсвечивать доску при клике на ячейки доски (при выполнении "хода" противника)
	var lastTurn = {};
	var eatPawn = {};  // вспомогательная переменная, хранящая информвцию о съеденной на проходе пешке
    var selected = {}; // словарь
	var stateHistory = {};	// словарь. ключ - состояние, значение - количество повторений
	var turnsCount = 0;		// количество ходов, при которых не было совершено ни одно взятие и не ходила ни одна пешка
	// допустимость рокировок. [белая левая ладья/белая правая ладья/черная левая ладья/черная правая ладья]
	var castlings = [true,true,true,true];

	var gameBlocked = true;		// глобальный флаг, указывающий на состояние игры (началась//не началась или уже закончилась)
	// когда он установлен, нажатия на поле игнорируются



	var socket = io.connect('http://localhost:9898');

	// обработчик сообщения от сервера со списком комнат
	socket.on('roomsList', function(msg) {
		//alert('!');
		console.log(msg);
		// составляем "всплывающее окно"
		var code = '<div>Choose room for spectrate:</div><br/>';
		for(var i=0;i<msg.length;i++){
			// заполняем варианты выбора комнат
			code+='<input type="radio" name="room" value="'+ msg[i].roomID +'"> Room-'+i+' (people in room:'+msg[i].length+')</input><br/>';
		}
		if(msg.length == 0){
			// если комнат нету
			code+='<div>No active rooms</div>'
		}
		// вставляем кнопки
		code+='<br/><input type="submit" value="Enter room" id="btn_enter"/><input type="submit" value="Cancel spectrate" id="btn_cancel"/>';

		// вставляем подготовленную разметку в div
		$('#roomsDiv').html(code);

		// обработчик кнопки "войти"
		// отписывается от изменений, убирает всплывающее окно и кнопки
		$('#btn_enter').click(function(){
			var choose = $( "input:radio:checked" ).val();
			socket.emit('roomsList_unsubscribe');
			if(choose != undefined){
				socket.emit('room_enter', {roomID:choose});
				$('#spectrate_btn').hide();
				$('#find_btn').hide();
				spectrator = true;
			}
			$('#roomsDiv').html('');
			$('#shadow').css('display','none');

		});

		// обработчик кнопки "отмена входа"
		// отписывается от изменений, убирает всплывающее окно
		$('#btn_cancel').click(function(){
			socket.emit('roomsList_unsubscribe');
			$('#shadow').css('display','none');
			$('#roomsDiv').html('');
		});
	});

	socket.on('message', function(msg) {
	  console.log(msg);
	});

	// обработчик сообщения о нахождении и старте игры. до старта игры пользователь не может двигать фигуры на доске
	socket.on('game_found', function(msg) {
		console.log(msg);
		// скрываем кнопку поиска игры и просмотра комнат
		$('#game_find_menu').hide();
		$('#spectrate_btn').hide();

		// если мы только смотрим, то последующая логика не нужна
		if(spectrator)
			return;

		// снимаем блокировку с игры
		gameBlocked = false;
		alert('Game started! You are: '+msg.color);
		// сохраняем цвет, которым будет играть текущий игрок
		playerWhite = msg.color == 'white';
	});

	// обработчик сообщения о передвижении соперника
	socket.on('player_move', function(msg) {
		console.log(msg);
		// переводим координаты из общего формата в свой
		var fr = DecodeCoordinates(msg.from.x, msg.from.y);
		var to = DecodeCoordinates(msg.to.x, msg.to.y);

		// если мы только смотрим, то используем упрощенное воспроизведение ходов
		if(spectrator){
			$('#'+to.y+'_'+to.x).html($('#'+fr.y+'_'+fr.x).html());
			$('#'+to.y+'_'+to.x).attr($('#'+fr.y+'_'+fr.x).attr('figure'));

			// очищаем исходную ячейку
			$('#'+fr.y+'_'+fr.x).attr('figure', null); // null в значении атрибута => удаление атрибута
			$('#'+fr.y+'_'+fr.x).html('');

			return;
		}

		// проверяем возможность такого хода и эмулируем нажатия на соответствующие фигуры
		if(CheckSecureOnMove(fr.x, fr.y, to.x, to.y, playerWhite? 'black':'white')){
			dontHighlight = true;	// отключаем подсветку на данном ходе
			extr = true;
			$('#'+fr.y+'_'+fr.x).click();		// вызываем событие клика у ячейки, как будто туда нажали мышкой
			extr = true;
			$('#'+to.y+'_'+to.x).click();
			dontHighlight = false;	// возвращаем подсветку
		}
		else{
			// если такой ход сделать нельзя, то ругаемся
			socket.emit('turnValidation_invalid');
		}
	});

	// обработчик сообщения о проведении рокировки
	socket.on('player_castling', function(msg) {
		console.log(msg);
		// переводим координаты из общего формата в свой
		var fr = DecodeCoordinates(msg.from.x, msg.from.y);
		var x = 4;
		var y = fr.y;		// y - не меняется на этом ходе

		var toX = fr.x == 0 ? 2 : 6;	// выясняем координаты, куда передвигается король

		// если мы только смотрим, то используем упрощенное воспроизведение ходов
		if(spectrator){
			$('#'+y+'_'+toX).html($('#'+y+'_'+x).html());
			$('#'+y+'_'+x).attr($('#'+y+'_'+x).attr('figure'));

			// очищаем исходную ячейку где был король
			$('#'+y+'_'+x).attr('figure', null); // null в значении атрибута => удаление атрибута
			$('#'+y+'_'+x).html('');

			// проверяем какую ладью надо сдвигать и куда
			if(toX == 2){
				$('#'+y+'_3').html($('#'+fr.y+'_'+fr.x).html());
				$('#'+y+'_3').attr($('#'+fr.y+'_'+fr.x).attr('figure'));
			}
			else{
				$('#'+y+'_5').html($('#'+fr.y+'_'+fr.x).html());
				$('#'+y+'_5').attr($('#'+fr.y+'_'+fr.x).attr('figure'));
			}

			// очищаем исходную ячейку с ладьей
			$('#'+fr.y+'_'+fr.x).attr('figure', null); // null в значении атрибута => удаление атрибута
			$('#'+fr.y+'_'+fr.x).html('');

			return;
		}

		// проверяем возможность такого хода и эмулируем нажатия на соответствующие фигуры
		if(CheckSecureOnMove(x, y, toX, y, playerWhite? 'black':'white')){
			dontHighlight = true;
			extr = true;
			$('#'+y+'_'+x).click();		// вызываем событие клика у ячеек доски
			extr = true;
			$('#'+y+'_'+toX).click();
			dontHighlight = false;
		}
		else{
			// если такой ход сделать нельзя, то ругаемся
			socket.emit('turnValidation_invalid');
		}
	});

	// обработчик сообщения о проводе пешки и замене её на другую фигуру
	socket.on('player_promotion', function(msg) {
		console.log(msg);
		// переводим координаты из общего формата в свой
		var fr = DecodeCoordinates(msg.from.x, msg.from.y);
		var to = DecodeCoordinates(msg.to.x, msg.to.y);

		// проверяем возможность такого хода и самостоятельно проводим необходимые действия с фигурами (нельзя отдавать основной логике из-за необходимости выбрать фигуру, на которую будет заменена пешка)
		// если мы только смотрим, то результат проверки не учитывается
		if(spectrator || CheckSecureOnMove(fr.x, fr.y, to.x, to.y, playerWhite? 'black':'white')){
			//$('#'+to.y+'_'+to.x).html($('#'+fr.y+'_'+fr.x).html());
			//$('#'+to.y+'_'+to.x).attr('figure', $('#'+fr.y+'_'+fr.x).attr('figure'));

			// очищаем исходную ячейку
			$('#'+fr.y+'_'+fr.x).attr('figure', null); // null в значении атрибута => удаление атрибута
			$('#'+fr.y+'_'+fr.x).html('');


			// в целевую ячейку сразу ставим запрошенную фигуру  // цвет выбирается относительно края, до которого дошла пешка
			$('#'+to.y+'_'+to.x).html('<img src="images/' + msg.newPiece + '_'+ (to.y!=0 ? 'black' : 'white') +'.png" class="figure" />');
			$('#'+to.y+'_'+to.x).attr('figure', msg.newPiece + '_' + (to.y!=0 ? 'black' : 'white'));
			whiteTurn = !whiteTurn;		// необходим ручной переход хода
		}
		else{
			// если такой ход сделать нельзя, то ругаемся
			socket.emit('turnValidation_invalid');
		}
		if(!spectrator)
			SetGameStateInfoText();
	});

	// обработчик сообщения о том, что игроку поставлен МАТ
	socket.on('player_mate', function(msg) {
		console.log(msg);
		if(spectrator){
			return;
		}
		// проверяем на МАТ
		if(CheckCheckmate(playerWhite ? 'black' : 'white')){
			socket.emit('turnValidation_mate');
		}
		else{
			// если данные некорректны, то ругаемся
			socket.emit('turnValidation_invalid');
		}
	});

	// обработчик сообшения о том, что произошла ничья (в рамках данного протокола - ПАТ)
	socket.on('player_draw', function(msg) {
		console.log(msg);
		if(spectrator){
			return;
		}
		// проверяем на ПАТ
		if(CheckStalemate(playerWhite ? 'black' : 'white')){
			socket.emit('turnValidation_draw');
		}
		else{
			// если данные некорректны, то ругаемся
			socket.emit('turnValidation_invalid');
		}
		SetGameStateInfoText();
	});

	// обработчик сообщения об окончании игры
	socket.on('game_end', function(msg) {
		console.log(msg);
		gameBlocked = true;		// блокируем любые действия с доской (а вдруг захочется оценить расстановку фигур в конце игры?)
		alert('Game ended. Winner:' + msg.winnerColor);
		SetGameStateInfoText();
	});



    $().ready(function(){
        build();
        fill();
		highLightBoard();
		SaveStateAndCheck();

		$('#ok_btn').click(function (){
			// обработчик кнопки "ОК" при выборе фигуры, на которую заменяется пешка
			var choose = $( "input:radio:checked" ).val();
			var white = lastTurn['figure'].indexOf('white') > -1;
			$('#'+lastTurn['toY']+'_'+lastTurn['toX']).html('<img src="images/' + choose + '_'+ (white ? 'white' : 'black') +'.png" class="figure" />');
			$('#'+lastTurn['toY']+'_'+lastTurn['toX']).attr('figure', choose + '_' + (white ? 'white' : 'black'));
			var fr = EncodeCoordinates(lastTurn['fromX'], lastTurn['fromY']);
			var to = EncodeCoordinates(lastTurn['toX'], lastTurn['toY']);
			socket.emit('turn_promotion',{ from:{x:fr.x, y:fr.y}, to:{x:to.x, y:to.y}, newPiece:choose});
			$('#choose_menu').css('display','none');
			whiteTurn = !whiteTurn;
		});

		// обработчик кнопки поиска комнат, показывающий всплывающее окно
		$('#spectrate_btn').click(function() {
			$('#shadow').css('display','block');	// показываем всплывающее окно
			socket.emit('roomsList_Subscribe');		// подписываемся на изменения в списке комнат
		});

		$('#find_btn').click(function(){
			// обработчик кнопки поиска игры
			if($(this).val() == 'Find game'){
				// заменяем текст на кнопке и отправляем серверу сообщение
				$(this).val('Stop finding');
				socket.emit('game_find');
				$('#spectrate_btn').hide();
			}
			else{
				// заменяем текст на кнопке и отправляем серверу сообщение
				$(this).val('Find game');
				socket.emit('game_stopFinding');
				$('#spectrate_btn').show();
			}
		});

    });
	function isItPossibleMove(x0,y0,x1,y1){
		var x0 = Number(x0);
		var x1 = Number(x1);
		var y0 = Number(y0);
		var y1 = Number(y1);
		if(x0<0 || y0<0 || x1<0 || y1<0 ||
			x0>7 || y0>7 || x1>7 || y1>7)
			return false;
		// source - откуда (источник)
		var src = $('#'+y0+'_'+x0);
		// destination - точка назначения
		var dest = $('#'+y1+'_'+x1);
		var attr = src.attr('figure');

		var dy = y1-y0;
		var dx = x1-x0;

		// split разбивает строку на массив строк с учетом переданного разделителя
		var type = attr.split('_')[0];

		if(type == undefined)
			return false;

		// получаем цвет ходящей фигуры: -1 || int>-1
		var white = attr.indexOf('white') > -1;
		var destEmpty = dest.attr('figure') == undefined;
		var destWhite = false;

		if(!destEmpty)
			destWhite = dest.attr('figure').indexOf('white') > -1;


		switch(type){
			case 'king':
				if(Math.abs(dx) > 1 || Math.abs(dy) > 1)
				{
					if(white){
						// рокировка
						// проверяем, что король ходит на 2 клетки в сторону со своей изначальной позиции
						if(dy == 0 && Math.abs(dx) == 2 && x0 == 4 && y0 == 7){
							// проверяем текущую позицию короля, возможность рокирования с ладьей, свободность всех клеток на пути движений
							// белый король рокируется с левой ладьей
							if(x1 == 2 && $('#7_1').attr('figure') == undefined && $('#7_3').attr('figure') == undefined
								&& destEmpty && castlings[0]){
								if(CheckSecureOnMove(4,7,2,7,'white', true) && CheckSecureOnMove(4,7,3,7,'white', true) && !CheckCheck('white')){
									return true;
								}
							}

							// белый король рокируется с правой ладьей
							if(x1 == 6 && $('#7_5').attr('figure') == undefined && destEmpty && castlings[1]){
								if(CheckSecureOnMove(4,7,5,7,'white', true) && CheckSecureOnMove(4,7,6,7,'white', true) && !CheckCheck('white')){
									return true;
								}
							}
						}
					}
					else if(!white) {
						// рокировка
						// проверяем, что король ходит на 2 клетки в сторону со своей изначальной позиции
						if(dy == 0 && Math.abs(dx) == 2 && x0 == 4 && y0 == 0){
							// проверяем текущую позицию короля, возможность рокирования с ладьей, свободность всех клеток на пути движений
							// черный король рокируется с левой ладьей
							if(x1 == 2 && $('#0_1').attr('figure') == undefined && $('#0_3').attr('figure') == undefined
								&& destEmpty && castlings[2]){
								if(CheckSecureOnMove(4,0,2,0,'black', true) && CheckSecureOnMove(4,0,3,0,'black', true) && (!CheckCheck('black'))){
									return true;
								}
							}

							// черный король рокируется с правой ладьей
							if(x1 == 6 && $('#0_5').attr('figure') == undefined && destEmpty && castlings[3]){
								if(CheckSecureOnMove(4,0,5,0,'black', true) && CheckSecureOnMove(4,0,6,0,'black', true) && (!CheckCheck('black'))){
									return true;
								}
							}
						}
					}
					return false;
				}
				if(white){
					if(!destEmpty && destWhite)
						return false;
					if((destEmpty || (!destEmpty && !destWhite)) && (Math.abs(dx) <= 1) && (Math.abs(dy) <= 1))
						return true;
				}
				else if(!white){
					if(!destEmpty && !destWhite)
						return false;
					if((destEmpty || (!destEmpty && destWhite)) && (Math.abs(dx) <= 1) && (Math.abs(dy) <= 1))
						return true;
				}
				break;
			case 'queen':
				if(white){
					if(!destEmpty && destWhite)
						return false;
					if((destEmpty || (!destEmpty && !destWhite))){
						if(Math.abs(dx) != Math.abs(dy)){
							if((dx != 0) && (dy != 0)){
								return false;
							}
						}
						if(dx == 0){
							if(dy> 0){
								for(var i = y0+1; i<y1;i++){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = y0-1; i>y1;i--){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
						else if(dy == 0){
							if(dx> 0){
								for(var i = x0+1; i<x1;i++){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = x0-1; i>x1;i--){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
						else if(Math.abs(dx) == Math.abs(dy)){
							if(dx > 0 && dy > 0){
								for(var i=x0+1, j=y0+1;i<x1,j<y1;i++,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else if(dx > 0 && dy < 0){
								for(var i=x0+1, j=y0-1;i<x1,j>y1;i++,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else if(dx < 0 && dy > 0){
								for(var i=x0-1, j=y0+1;i>x1,j<y1;i--,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i=x0-1, j=y0-1;i>x1,j>y1;i--,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				else if(!white){
					if(!destEmpty && !destWhite)
						return false;
					if((destEmpty || (!destEmpty && destWhite))){
						//&& (Math.abs(dx) < 1) && (Math.abs(dy)))
						//	return true;
						if(Math.abs(dx) != Math.abs(dy)){
							if((dx != 0) && (dy != 0)){
								return false;
							}
						}
						if(dx == 0){
							if(dy> 0){
								for(var i = y0+1; i<y1;i++){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = y0-1; i>y1;i--){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
						else if(dy == 0){
							if(dx> 0){
								for(var i = x0+1; i<x1;i++){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = x0-1; i>x1;i--){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
						else if(Math.abs(dx) == Math.abs(dy)){
							if(dx > 0 && dy > 0){
								for(var i=x0+1, j=y0+1;i<x1,j<y1;i++,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else if(dx > 0 && dy < 0){
								for(var i=x0+1, j=y0-1;i<x1,j>y1;i++,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else if(dx < 0 && dy > 0){
								for(var i=x0-1, j=y0+1;i>x1,j<y1;i--,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i=x0-1, j=y0-1;i>x1,j>y1;i--,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										////if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				break;
			case 'bishop':
				if(white){
					if(!destEmpty && destWhite)
						return false;
					if((destEmpty || (!destEmpty && !destWhite))){
						//&& (Math.abs(dx) < 1) && (Math.abs(dy)))
						//	return true;
						if(Math.abs(dx) != Math.abs(dy)){
							return false;
						}

						if(Math.abs(dx) == Math.abs(dy)){
							if(dx > 0 && dy > 0){
								for(var i=x0+1, j=y0+1;i<x1,j<y1;i++,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else if(dx > 0 && dy < 0){
								for(var i=x0+1, j=y0-1;i<x1,j>y1;i++,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else if(dx < 0 && dy > 0){
								for(var i=x0-1, j=y0+1;i>x1,j<y1;i--,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i=x0-1, j=y0-1;i>x1,j>y1;i--,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				else if(!white){
					if(!destEmpty && !destWhite)
						return false;
					if((destEmpty || (!destEmpty && destWhite))){
						//&& (Math.abs(dx) < 1) && (Math.abs(dy)))
						//	return true;
						if(Math.abs(dx) != Math.abs(dy)){
							return false;
						}
						if(Math.abs(dx) == Math.abs(dy)){
							if(dx > 0 && dy > 0){
								for(var i=x0+1, j=y0+1;i<x1,j<y1;i++,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else if(dx > 0 && dy < 0){
								for(var i=x0+1, j=y0-1;i<x1,j>y1;i++,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else if(dx < 0 && dy > 0){
								for(var i=x0-1, j=y0+1;i>x1,j<y1;i--,j++){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i=x0-1, j=y0-1;i>x1,j>y1;i--,j--){
									var atr = $('#'+j+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				break;
			case 'knight':
				var possible_moves  =
					[[-1, -2], [-2, -1], [-2,  1], [ 1, -2],
					 [-1,  2], [ 2, -1], [ 1,  2], [ 2,  1]];
				for(var i = 0;i<8;i++){
					if(dx == possible_moves[i][0] && dy == possible_moves[i][1] && (destEmpty || (!destEmpty && (destWhite != white))))
						return true;
				}
				return false;
				break;
			case 'rook':
				if(white){
					if(!destEmpty && destWhite)
						return false;
					if((destEmpty || (!destEmpty && !destWhite))){
						//&& (Math.abs(dx) < 1) && (Math.abs(dy)))
						//	return true;
						if((dx != 0) && (dy != 0)){
							return false;
						}
						if(dx == 0){
							if(dy> 0){
								for(var i = y0+1; i<y1;i++){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = y0-1; i>y1;i--){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
						else if(dy == 0){
							if(dx> 0){
								for(var i = x0+1; i<x1;i++){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = x0-1; i>x1;i--){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('white') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				else if(!white){
					if(!destEmpty && !destWhite)
						return false;
					if((destEmpty || (!destEmpty && destWhite))){
						if((dx != 0) && (dy != 0)){
							return false;
						}
						if(dx == 0){
							if(dy> 0){
								for(var i = y0+1; i<y1;i++){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = y0-1; i>y1;i--){
									var atr = $('#'+i+'_'+x0).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
						else if(dy == 0){
							if(dx> 0){
								for(var i = x0+1; i<x1;i++){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
							else{
								for(var i = x0-1; i>x1;i--){
									var atr = $('#'+y0+'_'+i).attr('figure');
									if(atr != undefined){
										//if(atr.indexOf('black') > -1)
											return false;
									}
								}
							}
						}
					}
					return true;
				}
				break;
			case 'pawn':
				if(white){
					if(dx==0){
						if(dy==-1 && destEmpty){
							return true;
						}
						else if (dy == -2 && y0==6 && destEmpty && ($('#5_'+x0).attr('figure') == undefined)){
							return true;
						}
						else
							return false;
					}
					// проверка для взятия на проходе
					// если цель пуста, предыдущей ходила пешка противника, она ходила на 2 клетки, мы ходим вбок и вперед на 2 клетки, ходим на нужный столбец,
					// координаты вражеской пешки корректны и она сдвинулась на 2 клетки с начальной позиции
					else if(destEmpty && (lastTurn['figure'] == 'pawn_black') && (Math.abs(lastTurn['fromY'] - lastTurn['toY'])==2)
							&& (Math.abs(dx) == 1) && (dy == -1) && (x1 == lastTurn['toX']) && (y1+1==lastTurn['toY']) && (lastTurn['toY']==3)){
							eatPawn['eat'] = true;
							eatPawn['x'] = lastTurn['toX'];
							eatPawn['y'] = lastTurn['toY'];
							return true;
					}
					else if ((Math.abs(dx) == 1) && (dy == -1) && !destEmpty && !destWhite ){
						return true;
					}

					else
						return false;
				}
				else if(!white){
					if(dx==0){
						if(dy==1 && destEmpty){
							return true;
						}
						else if (dy == 2 && y0==1 && destEmpty && ($('#2_'+x0).attr('figure') == undefined)){
							return true;
						}
						else
							return false;
					}
					else if(destEmpty && (lastTurn['figure'] == 'pawn_white') && (Math.abs(lastTurn['fromY'] - lastTurn['toY'])==2)
							&& (Math.abs(dx) == 1) && (dy == 1) && (x1 == lastTurn['toX']) && (y1-1==lastTurn['toY']) && (lastTurn['toY']==4)){
							eatPawn['eat'] = true;
							eatPawn['x'] = lastTurn['toX'];
							eatPawn['y'] = lastTurn['toY'];
							return true;
					}
					else if ((Math.abs(dx) == 1) && (dy == 1) && !destEmpty && destWhite ){
						return true;
					}
					else
						return false;
				}
				break;
		}
		return false;
	};

	function saveLastMove(x0,y0,x1,y1, figure){
		lastTurn['fromX'] = Number(x0);
		lastTurn['fromY'] = Number(y0);
		lastTurn['toX'] = Number(x1);
		lastTurn['toY'] = Number(y1);
		lastTurn['figure'] = figure;
		$('#choose_menu').css('display','none');

		// так как эта функция вызывается на каждом ходе, тут проверяем, дошла ли пешка до конца поля
		if(figure.indexOf('pawn') > -1){	// если это пешка
			var white = figure.indexOf('white') > -1;
			if(white){
				if(y0 == 1 && y1 == 0){
					// пешка белых дошла до конца поля
					$('#choose_menu').css('display','block');
					return true;
				}
			}
			else if(!white){
				if(y0 = 6 && y1 == 7){
					// пешка черных дошла до конца поля
					$('#choose_menu').css('display','block');
					return true;
				}
			}
		}
		return false;
	}

	// перевод координат из своего формата в общий
	function EncodeCoordinates(x,y){
		var coords = {x:'Z', y:(8-Number(y))};
		switch(Number(x)){
			case 0: coords.x = 'A'; break;
			case 1: coords.x = 'B'; break;
			case 2: coords.x = 'C'; break;
			case 3: coords.x = 'D'; break;
			case 4: coords.x = 'E'; break;
			case 5: coords.x = 'F'; break;
			case 6: coords.x = 'G'; break;
			case 7: coords.x = 'H'; break;
		}
		return coords;
	}

	// перевод координат из общего формата в свой
	function DecodeCoordinates(x,y){
		var coords = {x:9, y:(8-Number(y))};
		switch(x){
			case 'A': coords.x = 0; break;
			case 'B': coords.x = 1; break;
			case 'C': coords.x = 2; break;
			case 'D': coords.x = 3; break;
			case 'E': coords.x = 4; break;
			case 'F': coords.x = 5; break;
			case 'G': coords.x = 6; break;
			case 'H': coords.x = 7; break;
		}
		return coords;
	}

	function figureClick(){
		var extern = extr;		// флаг, указывающий, что действие эмулируется и отправлять серверу сообщения не нужно
		extr = false;
		if(gameBlocked){
			// проверяется глобальный флаг, указывающий на то, что игра начата/заблокирована (еще не началась или уже закончилась)
			return;
		}
		if($(this).attr('figure') != undefined){
			//if($(this).attr('figure').indexOf(playerWhite? 'black' : 'white') > -1){
			if(!extern && playerWhite != whiteTurn){
				// нельзя ходить за противника!
				return;
			}
		}

		// флаги, используемые в проверках на необходимость отправки сообщения серверу
		var draw = false;		// пока не используется
		var turn = false;	// обычный ход
		var promotion = false;	// проведение пешки
		var castling = false;	// рокировка
		$('#infobar').html('');
		if(selected['white'] == undefined && $(this).attr('figure') == undefined)
		{
			// нету выделенной и нажали на пустую
			return;
		}
		else if(whiteTurn && (selected['white'] == true) && ($(this).attr('figure') == undefined)){
			// белые делают ход
			if(CheckSecureOnMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), 'white')){
				// если saveLastMove вернет true - значит прошло проведение пешки
				promotion = saveLastMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), selected['figure']);

				$(this).html($('#'+selected['y']+'_'+selected['x']).html());
				$(this).attr('figure', $('#'+selected['y']+'_'+selected['x']).attr('figure'));
				$('#'+selected['y']+'_'+selected['x']).attr('figure', null); // null в значении атрибута => удаление атрибута
				$('#'+selected['y']+'_'+selected['x']).html('');

				if(eatPawn['eat'] == true){
					// если пешка сделала взятие на проходе
					$('#'+eatPawn['y']+'_'+eatPawn['x']).attr('figure', null);
					$('#'+eatPawn['y']+'_'+eatPawn['x']).html('');
					eatPawn = {};
				}

				// если текущих ход делает ладья (башня), то рокировка с ней более не возможна.
				// отмечаем, что возможности сделать рокировку с соответствующей ладьей более нету
				if(selected['x']==0 && selected['y']==7){
					castlings[0] = false;
				}
				else if(selected['x']==7 && selected['y']==7){
					castlings[1] = false;
				}

				// если король сдвигается, то рокировки более для него невозможны
				if(selected['figure'] == 'king_white'){
					// такой ход будет допустим только при выполнении рокировки
					if(selected['x']==4 && ($(this).attr('x') == 6 || $(this).attr('x') == 2)){
						if($(this).attr('x') == 6){
							// переносим ладью
							$('#7_5').html($('#7_7').html());
							$('#7_5').attr('figure', $('#7_7').attr('figure'));
							$('#7_7').html('');
							$('#7_7').attr('figure', null);
							var coords = EncodeCoordinates(7,7);
							if(!extern)   // проверка, что ход не эмулирован
								socket.emit('turn_castling', {from:{x:coords.x, y:coords.y}});    // отправляем данные о сделанной рокировке
							castling = true;    // устанавливаем флаг рокировки, чтобы не отправлялось обычное сообщение о ходе
						}
						else if($(this).attr('x') == 2){
							// переносим ладью
							$('#7_3').html($('#7_0').html());
							$('#7_3').attr('figure', $('#7_0').attr('figure'));
							$('#7_0').html('');
							$('#7_0').attr('figure', null);
							var coords = EncodeCoordinates(0,7);
							if(!extern)   // проверка, что ход не эмулирован
								socket.emit('turn_castling', {from:{x:coords.x, y:coords.y}});    // отправляем данные о сделанной рокировке
							castling = true;    // устанавливаем флаг рокировки, чтобы не отправлялось обычное сообщение о ходе
						}
					}
					castlings[0] = false;
					castlings[1] = false;
				}

				if(selected['figure'].indexOf('pawn') == -1){
					turnsCount ++;
					if(turnsCount >= 50){
						// произведено 50 ходов без взятий и движений пешками
						$('#curGameState2').html('50 turns rule activated!');
						draw = true;
					}
				}
				else {
					// сходили пешкой, сбрасываем счетчик
					turnsCount = 1;
				}


				if(!promotion) {whiteTurn = !whiteTurn;}    // перевод хода будет выполнен только после выбора фигуры, на которую будет заменена пешка

				if (SaveStateAndCheck()) {
					// если обнаружили трижды повторяющуюся позицию
					// повторение: состояние поля, доступные ходы (включая рокировки, взятия на проходе), текущего ходящего игрока
					$('#curGameState').html('Found three-times repeated position!');
					draw = true;
				}

				if(!promotion && !castling && !extern){    // если не проведение пешки, не рокировка, не эмуляцияя хода
					var fr = EncodeCoordinates(selected['x'], selected['y']);
					var to = EncodeCoordinates($(this).attr('x'),$(this).attr('y'));
					socket.emit('turn_move',{ from:{x:fr.x, y:fr.y}, to:{x:to.x, y:to.y}});    // отправляем данные о сделанном ходе
				}
				selected = {};
			}
		}
		else if(!whiteTurn && (selected['white'] == false) && ($(this).attr('figure') == undefined)){
			// черные делают ход
			if(CheckSecureOnMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), 'black')){
				// если saveLastMove вернет true - значит прошло проведение пешки
				promotion = saveLastMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), selected['figure']);

				$(this).html($('#'+selected['y']+'_'+selected['x']).html());
				$(this).attr('figure', $('#'+selected['y']+'_'+selected['x']).attr('figure'));
				$('#'+selected['y']+'_'+selected['x']).attr('figure', null);
				$('#'+selected['y']+'_'+selected['x']).html('');

				if(eatPawn['eat'] == true){
					// если пешка сделала взятие на проходе
					$('#'+eatPawn['y']+'_'+eatPawn['x']).attr('figure', null);
					$('#'+eatPawn['y']+'_'+eatPawn['x']).html('');
					eatPawn = {};
				}

				// если текущих ход делает ладья (башня), то рокировка с ней более не возможна.
				// отмечаем, что возможности сделать рокировку с соответствующей ладьей более нету
				if(selected['x']==0 && selected['y']==0){
					castlings[2] = false;
				}
				else if(selected['x']==7 && selected['y']==0){
					castlings[3] = false;
				}

				// если король сдвигается, то рокировки более для него невозможны
				if(selected['figure'] == 'king_black'){
					// такой ход будет допустим только при выполнении рокировки
					if(selected['x']==4 && ($(this).attr('x') == 6 || $(this).attr('x') == 2)){
						if($(this).attr('x') == 6){
							// переносим ладью
							$('#0_5').html($('#0_7').html());
							$('#0_5').attr('figure', $('#0_7').attr('figure'));
							$('#0_7').html('');
							$('#0_7').attr('figure', null);
							var coords = EncodeCoordinates(7,0);
							if(!extern)   // проверка, что ход не эмулирован
								socket.emit('turn_castling', {from:{x:coords.x, y:coords.y}});    // отправляем данные о сделанной рокировке
							castling = true;    // устанавливаем флаг рокировки, чтобы не отправлялось обычное сообщение о ходе
						}
						else if($(this).attr('x') == 2){
							// переносим ладью
							$('#0_3').html($('#0_0').html());
							$('#0_3').attr('figure', $('#0_0').attr('figure'));
							$('#0_0').html('');
							$('#0_0').attr('figure', null);
							var coords = EncodeCoordinates(0,0);
							if(!extern)   // проверка, что ход не эмулирован
								socket.emit('turn_castling', {from:{x:coords.x, y:coords.y}});    // отправляем данные о сделанной рокировке
							castling = true;    // устанавливаем флаг рокировки, чтобы не отправлялось обычное сообщение о ходе
						}
					}
					castlings[2] = false;
					castlings[3] = false;
				}

				if(selected['figure'].indexOf('pawn') == -1){
					turnsCount ++;
					if(turnsCount >= 50){
						// произведено 50 ходов без взятий и движений пешками
						$('#curGameState2').html('50 turns rule activated!');
					}
				}
				else {
					// сходили пешкой, сбрасываем счетчик
					turnsCount = 1;
				}

				if(!promotion && !castling && !extern){    // если не проведение пешки, не рокировка, не эмуляцияя хода
					var fr = EncodeCoordinates(selected['x'], selected['y']);
					var to = EncodeCoordinates($(this).attr('x'),$(this).attr('y'));
					socket.emit('turn_move',{ from:{x:fr.x, y:fr.y}, to:{x:to.x, y:to.y}});    // отправляем данные о сделанном ходе
				}
				selected = {};
				if(!promotion) {whiteTurn = !whiteTurn;}    // перевод хода будет выполнен только после выбора фигуры, на которую будет заменена пешка
				if (SaveStateAndCheck()) {
					// если обнаружили трижды повторяющуюся позицию
					// повторение: состояние поля, доступные ходы (включая рокировки, взятия на проходе), текущего ходящего игрока
					$('#curGameState').html('Found three-times repeated position!');
				}
			}
		}	// indexOf - поиск подстроки. Нашел > -1
		else if(whiteTurn && ($(this).attr('figure').indexOf('white')>-1)){
			// белые выделяют свою фигуру
			$('#infobar').append('<div>Coordinates are: {X=' + $(this).attr('x')+'; Y='+$(this).attr('y') + '}</div>');
			$('#infobar').append('<div>User clicked: ' + $(this).attr('figure')+'</div>');

			selected['figure'] = $(this).attr('figure');
			selected['x'] = $(this).attr('x');
			selected['y'] = $(this).attr('y');
			selected['white'] = true;
		}
		else if(whiteTurn && ($(this).attr('figure').indexOf('black')>-1) && (selected['white'] == true)){
			// белые едят черных в случае возможности хода
			if(CheckSecureOnMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), 'white')){
				// если saveLastMove вернет true - значит прошло проведение пешки
				promotion = saveLastMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), selected['figure']);

				$(this).html($('#'+selected['y']+'_'+selected['x']).html());
				$(this).attr('figure', $('#'+selected['y']+'_'+selected['x']).attr('figure'));
				$('#'+selected['y']+'_'+selected['x']).attr('figure', null);
				$('#'+selected['y']+'_'+selected['x']).html('');

				// если текущих ход делает ладья (башня), то рокировка с ней более не возможна.
				// отмечаем, что возможности сделать рокировку с соответствующей ладьей более нету
				if(selected['x']==0 && selected['y']==7){
					castlings[0] = false;
				}
				else if(selected['x']==7 && selected['y']==7){
					castlings[1] = false;
				}

				// если король сдвигается, то рокировки более для него невозможны
				if(selected['figure'] == 'king_white'){
					castlings[0] = false;
					castlings[1] = false;
				}

				// произведено взятие, сбрасываем счетчик
				turnsCount = 1;
				if(!promotion && !castling && !extern){    // если не проведение пешки, не рокировка, не эмуляцияя хода
					var fr = EncodeCoordinates(selected['x'], selected['y']);
					var to = EncodeCoordinates($(this).attr('x'),$(this).attr('y'));
					socket.emit('turn_move',{ from:{x:fr.x, y:fr.y}, to:{x:to.x, y:to.y}});    // отправляем данные о сделанном ходе
				}
				selected = {};
				if(!promotion) {whiteTurn = !whiteTurn;}    // перевод хода будет выполнен только после выбора фигуры, на которую будет заменена пешка
				if (SaveStateAndCheck()) {
					// если обнаружили трижды повторяющуюся позицию
					// повторение: состояние поля, доступные ходы (включая рокировки, взятия на проходе), текущего ходящего игрока
					$('#curGameState').html('Found three-times repeated position!');
				}
			}
		}
		else if(!whiteTurn && ($(this).attr('figure').indexOf('black')>-1)){
			// черные выделяют свою фигуру
			$('#infobar').append('<div>Coordinates are: {X=' + $(this).attr('x')+'; Y='+$(this).attr('y') + '}</div>');
			$('#infobar').append('<div>User clicked: ' + $(this).attr('figure')+'</div>');

			selected['figure'] = $(this).attr('figure');
			selected['x'] = $(this).attr('x');
			selected['y'] = $(this).attr('y');
			selected['white'] = false;
		}
		else if(!whiteTurn && ($(this).attr('figure').indexOf('white')>-1) && (selected['white'] == false)){
			// очень голодные черные
			if(CheckSecureOnMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), 'black')){
				// если saveLastMove вернет true - значит прошло проведение пешки
				promotion = saveLastMove(selected['x'], selected['y'], $(this).attr('x'), $(this).attr('y'), selected['figure']);

				$(this).html($('#'+selected['y']+'_'+selected['x']).html());
				$(this).attr('figure', $('#'+selected['y']+'_'+selected['x']).attr('figure'));
				$('#'+selected['y']+'_'+selected['x']).attr('figure', null);
				$('#'+selected['y']+'_'+selected['x']).html('');

				// если текущих ход делает ладья (башня), то рокировка с ней более не возможна.
				// отмечаем, что возможности сделать рокировку с соответствующей ладьей более нету
				if(selected['x']==0 && selected['y']==0){
					castlings[2] = false;
				}
				else if(selected['x']==7 && selected['y']==0){
					castlings[3] = false;
				}

				// если король сдвигается, то рокировки более для него невозможны
				if(selected['figure'] == 'king_black'){
					castlings[2] = false;
					castlings[3] = false;
				}

				// произведено взятие, сбрасываем счетчик
				turnsCount = 1;
				if(!promotion && !castling && !extern){    // если не проведение пешки, не рокировка, не эмуляцияя хода
					var fr = EncodeCoordinates(selected['x'], selected['y']);
					var to = EncodeCoordinates($(this).attr('x'),$(this).attr('y'));
					socket.emit('turn_move',{ from:{x:fr.x, y:fr.y}, to:{x:to.x, y:to.y}});    // отправляем данные о сделанном ходе
				}
				selected = {};
				if(!promotion) {whiteTurn = !whiteTurn;}    // перевод хода будет выполнен только после выбора фигуры, на которую будет заменена пешка
				if (SaveStateAndCheck()) {
					// если обнаружили трижды повторяющуюся позицию
					// повторение: состояние поля, доступные ходы (включая рокировки, взятия на проходе), текущего ходящего игрока
					$('#curGameState').html('Found three-times repeated position!');
				}
			}
		}
		else{
			selected = {};
		}


		highLightBoard();
		SetGameStateInfoText();
		//socket.emit('message', 'message to server');
	};

	function SetGameStateInfoText(){
		// устанавливаем текст над игровым полем, который показывает текущее состояние игровой доски
		if(CheckCheckmate('white')){
			$('#curMoveColor').append('Checkmate to white!');
		}
		else if(CheckCheckmate('black')) {
			$('#curMoveColor').append('Checkmate to black!');
		}
		else if(CheckCheck('white')){
			$('#curMoveColor').append('Check to white!');
		}
		else if (CheckCheck('black')) {
			$('#curMoveColor').append('Check to black!');
		}
		else if (CheckStalemate('white')) {
			$('#curMoveColor').append('Stalemate to white!');
		}
		else if (CheckStalemate('black')) {
			$('#curMoveColor').append('Stalemate to black!');
		}
	}

	function highLightBoard(){
		// убираем выделение со всех ячеек
		// removeClass - Удаляет все или указанный(е) класс(ы) из набора совпавших элементов.
		$('.square').removeClass('square_highlighted');
		$('.square').removeClass('figure_highlighted');


		if(selected['figure'] != undefined && !dontHighlight){
			var x0 = Number(selected['x']);
			var y0 = Number(selected['y']);

			$('#'+y0+'_'+x0).addClass('figure_highlighted');

			for(var x=0; x<8; x++){
				for(var y=0; y<8; y++){
					if(CheckSecureOnMove(x0,y0,x,y, selected['figure'].split('_')[1])){
						$('#'+y+'_'+x).addClass('square_highlighted');
					}
				}
			}
		}
		if(whiteTurn)
			$('#curMoveColor').html('White turn! ' + 'You are:' + gameBlocked? '' : (playerWhite? 'white' : 'black'));
		else {
			$('#curMoveColor').html('Black turn! ' + 'You are:' + gameBlocked? '' : (playerWhite? 'white' : 'black'));
		}
	}

	function CheckCheck(color){
		// проверяем на шах
		// проходим по всем ячейкам и проверяем, могут ли "сходить" на короля
		for(var x0=0; x0<8; x0++){
			for(var y0=0; y0<8; y0++){
				if($('#'+y0+'_'+x0).attr('figure') != undefined){
					for(var x=0; x<8; x++){
						for(var y=0; y<8; y++){
							if($('#'+y+'_'+x).attr('figure') != undefined){
								if(isItPossibleMove(x0,y0,x,y) && $('#'+y+'_'+x).attr('figure') == ('king_'+color)){
									return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	function CheckSecureOnMove(x0,y0,x1,y1,color, dontCheckPossibility){
		// проверяем возможность хода с точки зрения короля
		// то есть, что при данном ходе мы не подставляем короля под ШАХ
		// сначала мы сохраняем состояния начальной и целевой клеток
		// затем "делаем ход", проверяем состояние ШАХа, потом возвращаем состояние доски обратно
		// при выполнении виртуального хода достаточно только поменять атрибуты клеток без замены картинок, так как только атрибуты имеют значение
		var srcAttr = $('#'+y0+'_'+x0).attr('figure');	// состояние начальной клетки
		var destAttr = $('#'+y1+'_'+x1).attr('figure');	// состояние целевой клетки
		var secure = true;		// флаг - ход безопасен

		// такой случай происходит когда нам не нужно проверять "корректность" хода повторно, например при вызове этого метода из isItPossibleMove, для избежания рекурсии
		if(dontCheckPossibility != undefined){
			$('#'+y1+'_'+x1).attr('figure', $('#'+y0+'_'+x0).attr('figure'));
			$('#'+y0+'_'+x0).attr('figure', null); // null в значении атрибута => удаление атрибута
			secure = !CheckCheck(color);
		}
		else if(isItPossibleMove(x0,y0,x1,y1)){
			$('#'+y1+'_'+x1).attr('figure', $('#'+y0+'_'+x0).attr('figure'));
			$('#'+y0+'_'+x0).attr('figure', null); // null в значении атрибута => удаление атрибута
			secure = !CheckCheck(color);
		}
		else{
			secure = false;
		}
		// возвращаем состояния клеткам доски
		$('#'+y1+'_'+x1).attr('figure', destAttr == undefined ? null : destAttr);
		$('#'+y0+'_'+x0).attr('figure', srcAttr == undefined ? null : srcAttr); // null в значении атрибута => удаление атрибута
		return secure;
	}

	function CheckCheckmate(color){
		// проверяем на ШАХ И МАТ
		var checkmate = true;	// флаг - шах и мат

		for(var x0=0; x0<8; x0++){
			for(var y0=0; y0<8; y0++){
				if(($('#'+y0+'_'+x0).attr('figure') != undefined) && ($('#'+y0+'_'+x0).attr('figure').indexOf(color) > -1)){
					for(var x=0; x<8; x++){
						for(var y=0; y<8; y++){
							// проверяем для каждой фигуры атакованного игрока возможность сделать безопасный для короля ход
							// то есть такой, в результате которого он не будет под ШАХОМ
							if(CheckSecureOnMove(x0,y0,x,y,color)){
								// если такой ход найден, то МАТ не поставлен
								checkmate = false;
							}
						}
					}
				}
			}
		}
		// ШАХ И МАТ, если игрок не может выйти из под ШАХА
		return checkmate && CheckCheck(color);
	}

	function CheckStalemate(color){
		// проверяем на ПАТ
		var stalemate = true;


		for(var x0=0; x0<8; x0++){
			for(var y0=0; y0<8; y0++){
				if(($('#'+y0+'_'+x0).attr('figure') != undefined) && ($('#'+y0+'_'+x0).attr('figure').indexOf(color) > -1)){
					for(var x=0; x<8; x++){
						for(var y=0; y<8; y++){
							// проверяем для каждой фигуры атакованного игрока возможность сделать безопасный для короля ход
							// то есть такой, в результате которого он не будет под ШАХОМ
							if(CheckSecureOnMove(x0,y0,x,y,color)){
								// если такой ход найден, то ПАТА нету
								stalemate = false;
							}
						}
					}
				}

			}
		}
		// ПАТ аналогичен МАТУ, но при этом игрок не находится под ШАХОМ
		return stalemate;
	}

	function SaveStateAndCheck(){
		// сохраняем состояние доски и заодно проверяем, не повторялась ли ситуация 3 и более раз

		// состояние доски храним в словаре
		// ключ (само состояние) составляется как сумма информации о:
		// состоянии ячеек, текущем игроке, возможных ходах (включая рокировки и взятия на проходе)
		var currentState = $('#board');	// добавляем к ключу текущее состояние ячеек доски
		currentState += castlings; 	// добавляем к ключу возможности рокировок
		currentState += whiteTurn;	// добавляем к ключу текущего игрока

		for(var x0=0; x0<8; x0++){
			for(var y0=0; y0<8; y0++){
				if($('#'+y0+'_'+x0).attr('figure') != undefined){
					var color = $('#'+y0+'_'+x0).attr('figure').indexOf('white') > -1 ? 'white' : 'black';
					for(var x=0; x<8; x++){
						for(var y=0; y<8; y++){
							// ищем для каждой фигуры на доске возможные ходы и добавляем их к ключу
							if(CheckSecureOnMove(x0,y0,x,y,color)){
								currentState += x0+y0+x+y;
							}
						}
					}
				}

			}
		}

		if(stateHistory[currentState] == undefined){
			// если такого состояния еще не было, то добавляем его с числом повторений = 1
			stateHistory[currentState] = 1;
		}
		else {
			// если такое состояние уже было, то увеличиваем счетчик
			stateHistory[currentState] += 1;
		}

		if(stateHistory[currentState] >= 3){
			// если таких состояний было не менее трех
			return true;
		}
		return false;
	}


	/*
	Базовые селекторы jQuery

	"*" - все элементы
	".className" - элементы с классом className
	"#idName" - элемент (один!) с идентификатором idName
	"tagName" - элементы с заданным именем тега
	*/

    function build(){
        var white = true;
        for(var i = 0;i<8;i++){
            for(var j = 0;j<8;j++){
				// append добавляет разметку внутрь выбранного объекта
                $('#board').append('<div x="'+j+'" y="' + i+'" id="'+ i+'_'+j +'"class="square '+ (white ? 'square_white' : 'square_black') + '"></div>');
				// вешаем обработчик на клик по добавленному div'у (в параметре имя функции)
				$('#'+i+'_'+j).click(figureClick);
                white = !white;


            }
            white = !white;
        }
    }
    function fill(){
		// html() - вернет внутреннюю разметку
		// html('smth') - перезапишет внутреннюю разметку на smth
        $('#0_0').html('<img src="images/rook_black.png" class="figure" />')
        $('#0_7').html('<img src="images/rook_black.png" class="figure" />')
        //$('#0_1').html('<img src="images/knight_black.png" class="figure" />')
        //$('#0_6').html('<img src="images/knight_black.png" class="figure" />')
        //$('#0_2').html('<img src="images/bishop_black.png" class="figure" />')
        //$('#0_5').html('<img src="images/bishop_black.png" class="figure" />')
        //$('#0_3').html('<img src="images/queen_black.png" class="figure" />')
		$('#0_4').html('<img src="images/king_black.png" class="figure" />')


        $('#7_0').html('<img src="images/rook_white.png" class="figure" />')
        $('#7_7').html('<img src="images/rook_white.png" class="figure" />')
        //$('#7_1').html('<img src="images/knight_white.png" class="figure" />')
        //$('#7_6').html('<img src="images/knight_white.png" class="figure" />')
        //$('#7_2').html('<img src="images/bishop_white.png" class="figure" />')
        //$('#7_5').html('<img src="images/bishop_white.png" class="figure" />')
        //$('#7_3').html('<img src="images/queen_white.png" class="figure" />')
        $('#7_4').html('<img src="images/king_white.png" class="figure" />')

		// attr(name, value)
        $('#0_0').attr('figure', 'rook_black')
        $('#0_7').attr('figure', 'rook_black')
        //$('#0_1').attr('figure', 'knight_black')
        //$('#0_6').attr('figure', 'knight_black')
        //$('#0_2').attr('figure', 'bishop_black')
        //$('#0_5').attr('figure', 'bishop_black')
        //$('#0_3').attr('figure', 'queen_black')
		$('#0_4').attr('figure', 'king_black')


        $('#7_0').attr('figure', 'rook_white')
        $('#7_7').attr('figure', 'rook_white')
        //$('#7_1').attr('figure', 'knight_white')
        //$('#7_6').attr('figure', 'knight_white')
        //$('#7_2').attr('figure', 'bishop_white')
        //$('#7_5').attr('figure', 'bishop_white')
        //$('#7_3').attr('figure', 'queen_white')
        $('#7_4').attr('figure', 'king_white')

        for(var i = 0;i<8;i++){
            $('#1_'+i).html('<img src="images/pawn_black.png" class="figure" />');
            $('#6_'+i).html('<img src="images/pawn_white.png" class="figure" />');

            $('#1_'+i).attr('figure', 'pawn_black');
            $('#6_'+i).attr('figure', 'pawn_white');
        }


		$('#1_5').html('<img src="images/pawn_white.png" class="figure" />')
		$('#1_5').attr('figure', 'pawn_white')

    }
	</script>
</head>
<body>
	<div id="game_find_menu">
		<input type="submit" value="Find game" id="find_btn"/>
		<input type="submit" value="Spectrate" id="spectrate_btn"/>
	</div>
	<div class="modal" style="display:none" id="shadow">
	</div>
	<div id="roomsDiv" style="top:50%;left:50%;position:absolute;z-index:9002;background-color:white;opacity:0.8;"></div>

	<div id="choose_menu" style="display:none">
		<input type="radio" name="fig" value="queen"> Queen </input>
	   	<input type="radio" name="fig" value="knight"> Knight </input>
		<input type="radio" name="fig" value="bishop"> Bishop </input>
		<input type="radio" name="fig" value="rook"> Rook </input>

		<input type="submit" value="OK" id="ok_btn"/>
	</div>
	<div><h2 id="curMoveColor" ></h2><h2 id="curGameState" ></h2><h2 id="curGameState2" ></h2></div>
	<div id="board" class="board"></div>
	<div id="infobar"></div>
</body>

</html>
